TUGAS 2
1. - Pertama saya memulai dengan menyiapkan repository baru di GitHub dengan nama sesuai tema aplikasi yang saya pilih, yaitu Football_Shop. Setelah itu saya membuat folder lokal khusus di komputer saya, lalu membuat dan mengaktifkan virtual environment.
- Setelah environment aktif, saya melakukan instalasi utama, yaitu Django beserta library pendukung lain yang diperlukan.
- Saya juga menambahkan environment variables agar informasi sensitif (seperti konfigurasi database, secret key, dan host) tidak langsung ditulis di dalam kode. Variabel ini saya simpan di file .env dan dipanggil lewat konfigurasi di settings.py. Pada bagian ini, saya juga menambahkan domain yang diizinkan ke dalam ALLOWED_HOSTS agar proyek bisa dijalankan baik secara lokal maupun setelah deployment.
- Setelah proyek siap, saya menjalankan perintah python manage.py makemigrations dan python manage.py migrate untuk melakukan sinkronisasi model dengan database. Saya lalu mencoba menjalankan server (python manage.py runserver) untuk memastikan proyek sudah dapat diakses.  Setelah berhasil, saya menghentikan server dan melakukan commit awal ke repository GitHub.
- Langkah berikutnya adalah membuat aplikasi baru bernama main dengan perintah python manage.py startapp main. Supaya aplikasi ini dikenali, saya masukkan di INSTALLED_APPS pada settings.py. Pada models.py, saya membuat model Product dengan atribut wajib (name, price, description, thumbnail, category, dan is_featured) sesuai instruksi soal dengan beberapa tambahan. Saya juga menambahkan beberapa atribut tambahan seperti stock untuk menunjukkan brand.
- Setelah model selesai, saya beralih ke views. Di views.py, saya membuat fungsi yang mengembalikan informasi sederhana berupa nama aplikasi, nama saya, dan kelas. Fungsi ini kemudian saya hubungkan dengan routing di urls.py. Dengan begitu, ketika saya mengakses, data tersebut bisa ditampilkan melalui file template HTML (index.html) yang saya buat di folder templates
- Tahap terakhir adalah melakukan deployment ke PWS. Saya membuat project baru di PWS dengan nama footballshop, kemudian mengatur beberapa konfigurasi deployment seperti schema dan pengaturan production. Setelah semua siap, saya push kode terbaru ke repository GitHub, lalu menghubungkannya dengan PWS. Selama proses deployment, saya memantau log server untuk memastikan tidak ada error. Jika berhasil, aplikasi saya dapat diakses oleh orang lain secara online melalui URL PWS yang sudah disediakan.

2. https://drive.google.com/file/d/1gAsc6-vegd6UporiDpAEhwf9-g3FwCgN/view?usp=drivesdk 
Prosesnya dimulai dari client mengirim request melalui internet yang diterima oleh Django. Request tersebut diteruskan ke views.py untuk diproses. Jika membutuhkan data dari database, views.py akan memanggil models.py untuk mengambil data. Setelah data didapatkan, hasilnya dikirim kembali ke views.py, lalu diteruskan ke template HTML untuk dirender. Terakhir, Django mengirimkan response tersebut kembali ke client melalui internet.

3. settings.py adalah pusat pengaturan utama di dalam proyek Django. Semua hal penting yang mengontrol jalannya aplikasi disimpan di file ini. Misalnya, daftar aplikasi apa saja yang dipakai, pengaturan database tempat data disimpan, lokasi template HTML, hingga file statis seperti CSS, gambar, dan JavaScript. Bukan cuma itu, settings.py juga ngurus hal-hal penting soal keamanan, misalnya ALLOWED_HOSTS supaya aplikasi hanya bisa diakses dari domain tertentu. Tanpa file ini, djago tidak akan bisa berdiri dengan baik.

4. Proses migrasi dimulai dengan menjalankan perintah makemigrations. Pada tahap ini, Django membaca perubahan yang terjadi pada model, misalnya penambahan atribut baru atau perubahan tipe data, lalu menghasilkan file migrasi. Tahap berikutnya adalah menjalankan migrate. Perintah ini akan mengeksekusi file migrasi dan menerapkannya pada database. Hasilnya, struktur database diperbarui secara otomatis, misalnya dengan membuat tabel baru, menambah kolom, atau memodifikasi struktur tabel yang sudah ada.

5. Django dipilih sebagai framework pertama karena sudah menyediakan banyak fitur bawaan yang memudahkan pemula untuk belajar membuat aplikasi web tanpa harus mengatur semuanya dari awal. Django memiliki struktur yang jelas dengan pemisahan antara data, logika, dan tampilan (MVT), sehingga konsep dasar pembuatan web lebih mudah dipahami. Selain itu, Django juga aman, memiliki dokumentasi resmi yang lengkap, serta didukung komunitas besar yang aktif. Dengan semua kelebihan ini, Django cocok untuk langkah awal sebelum beralih ke framework lain yang lebih kompleks.

6. Penjelasan dari web oleh asdos pada tutorial 1 cukup jelas dan membantu memahami dasar penggunaan Django, terutama dalam mengenal struktur proyek dan cara menjalankan server

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
TUGAS 3
1. Dalam pengembangan platform, data delivery diperlukan karena aplikasi tidak selalu berhenti pada tampilan HTML. sering kali data yang sama harus “dipindahkan” dari satu stack ke stack lain misalnya dari backend ke antarmuka web atau mobile dalam format yang mudah diproses oleh berbagai klien. Materi menekankan bahwa format yang lazim untuk tujuan ini adalah HTML, XML, dan JSON. Implementasi berbasis HTML sudah dibahas pada tutorial sebelumnya, sedangkan pada tutorial ini kamu diarahkan menyiapkan endpoint XML dan JSON agar data backend dapat diakses sebagai representasi terstruktur, bukan hanya sebagai halaman untuk manusia. View seperti show_xml dan show_json yang mengambil queryset lalu menyusunnya dengan serializers.serialize hasilnya dikembalikan melalui HttpResponse dengan content_type yang tepat (mis. application/xml atau application/json) agar mengetahui cara memparsing respons tersebut. Data delivery bukan hanya soal “mengirim data”, melainkan juga memastikan interoperabilitas, keterbacaan mesin, dan verifikasi melalui alat uji yang standar.

2. 
- XML : format berbasis tag yang self descriptive: setiap elemen menjelaskan dirinya sendiri dan disusun sebagai pohon (tree) yang wajib memiliki root element sebagai induk dari elemen lain. Dokumen XML lazim menyertakan XML prolog di awal, setiap elemen wajib memiliki closing tag, dan seluruh tag bersifat case-sensitive. XML dipakai di aplikasi web dan mobile untuk penyimpanan dan pertukaran data, sementara program user yang akan mengirim, menerima, menyimpan, atau menampilkan informasi dari berkas XML tersebut.
- JSON : format teks yang self describing, umum dipakai di aplikasi web/mobile untuk menyimpan dan mentransfer data. Walaupun berasal dari objek JavaScript, JSON bukanlah kode murni teks sehingga banyak bahasa pemrograman memiliki dukungan bawaan untuk membaca dan membuatnya. Struktur datanya berbasis key value dan objek, dengan nilai yang dapat berupa tipe primitif (string, number, boolean).

3. Pada Django, is_valid() menjalankan pipeline validasi (full_clean) pada Form memeriksa aturan level field (required, tipe, panjang, choices), level form (clean()), hingga level model lalu mengembalikan True jika lolos dan mengisi cleaned_data, atau False jika ada kesalahan (tersedia di form.errors). Karena itu, pada alur POST kita selalu memanggilnya sebelum form.save() agar data tidak sah/inkonsisten masuk ke basis data dan validasi server side tetap terjaga meski validasi client dimatikan. Jika validasi gagal, kembalikan form yang sama ke template supaya pesan error tampil dan isian pengguna tidak hilang. Saat perlu menyetel field tambahan sebelum simpan, gunakan form.save(commit=False); dan untuk form dengan unggahan berkas, sertakan request.FILES.

4. Token keamanan yang dibuat otomatis oleh Django dan disisipkan ke dalam setiap form POST untuk membuktikan bahwa permintaan benar-benar berasal dari halaman aplikasi. Saat form dikirim, server akan memeriksa kecocokan token, jika token absen atau tidak valid, Django dapat menolak permintaan tersebut dan—yang lebih berbahaya tanpa token aplikasi menjadi rentan terhadap Cross-Site Request Forgery (CSRF), yaitu skenario ketika penyerang menitipkan permintaan dari situs lain agar browser korban tanpa sadar mengeksekusi aksi di aplikasi. Karena itu, penyertaan {% csrf_token %} di template form wajib, dan pada saat deployment juga diminta mengkonfigurasi CSRF_TRUSTED_ORIGINS (menggunakan URL berawalan https://) agar validasi CSRF tetap berjalan benar di domain produksi.

5. 
- Membuat 4 fungis di views.py
Dua fungsi ini bertugas untuk mengembalikan seluruh data dari model ke dalam format yang berbeda, yaitu XML dan JSON. Pertama, data diambil dari database menggunakan query Model.objects.all(), yang akan mengembalikan queryset berisi seluruh objek. Queryset ini kemudian diubah (diserialisasi) menggunakan fungsi serializers.serialize() milik Django. Parameter "xml" atau "json" menentukan format hasil serialisasi. Setelah diserialisasi, data dikirim kembali kepada pengguna melalui HttpResponse, dengan content_type yang sesuai (application/xml atau application/json) agar browser atau aplikasi lain tahu bagaimana cara memproses respon tersebut. Sedangkan, show_xml_by_id dan show_json_by_id fokus pada satu objek tertentu. Data diambil berdasarkan primary key (ID) menggunakan get() atau filter(). Karena serializer mengharapkan data berbentuk iterable (seperti list atau queryset), objek tunggal yang diambil dibungkus ke dalam list sebelum diproses. Ini adalah detail teknis kecil yang penting, karena tanpa dibungkus list akan terjadi error. Selain itu, praktik baiknya adalah membungkus fungsi dengan blok try except. Jika data dengan ID tersebut tidak ada, maka fungsi mengembalikan HttpResponse dengan status 404 (Not Found). Hal ini penting supaya API tetap konsisten dan tidak memberikan data kosong tanpa keterangan. Dengan begitu, API dapat diandalkan untuk memberikan informasi yang benar, baik dalam kondisi data ada maupun tidak ada.

- Setelah views selesai dibuat, langkah berikutnya adalah menambahkan path baru pada urls.py. Routing berfungsi sebagai jembatan antara URL yang diakses pengguna dengan fungsi view yang dijalankan. Pada tahap ini, ditambahkan path baru untuk masing-masing view xml, json, xml id, json id. Dengan menambahkan name pada setiap path, setiap endpoint bisa dipanggil kembali dengan mudah dari template maupun bagian lain kode. URL juga mempermudah proses pengujian menggunakan tools seperti Postman.

- Halaman utama main.html untuk menampilkan daftar data dari model secara dinamis. Data diambil di view (show_main) menggunakan query Product.objects.all() (atau sesuai model yang digunakan), kemudian dikirimkan ke template dalam bentuk context. Di dalam template, data ini ditampilkan dalam tabel atau daftar dengan informasi dasar setiap objek. Untuk meningkatkan interaksi pengguna, ditambahkan tombol “Add” yang mengarahkan user ke halaman form input. Tombol ini membantu pengguna menambahkan data baru tanpa harus mengetik URL secara manual. Selain itu, pada setiap objek ditambahkan tombol “Detail”. Tombol ini memberikan akses cepat ke halaman detail untuk melihat informasi lebih lengkap dari objek tersebut.

- Untuk menambahkan data baru, digunakan ModelForm yang didefinisikan di forms.py. ModelForm mempermudah pembuatan form karena field yang ditampilkan langsung mengikuti definisi field pada model. Ini mengurangi duplikasi kode, karena tidak perlu mendefinisikan ulang setiap field. View create_product mengatur alur kerja form. Pertama, view menampilkan form kosong ketika request berupa GET. Jika request berupa POST, data dari form diproses. Fungsi form.is_valid() dijalankan untuk mengecek apakah input pengguna sesuai dengan aturan validasi model. Jika valid, data disimpan ke database menggunakan form.save(), lalu pengguna diarahkan kembali ke halaman utama menggunakan redirect(). Template create_product.html memanfaatkan {% csrf_token %}. Token ini sangat penting karena menjadi mekanisme keamanan untuk mencegah CSRF attack. Tanpa token ini, aplikasi rawan dihack oleh pihak luar yang bisa memaksa pengguna mengirimkan form secara tidak sah. Field ditampilkan menggunakan {{ form.as_table }} atau {{ form.as_p }}, yang otomatis merender form sesuai field model.

- Fungsi show_product bertugas menampilkan informasi lengkap dari satu objek. Fungsi ini menggunakan get_object_or_404() untuk mengambil data berdasarkan ID. Keuntungan menggunakan get_object_or_404() dibandingkan get() adalah jika data dengan ID yang diminta tidak ada, Django otomatis mengembalikan halaman 404. Ini lebih aman dan rapi dibandingkan membiarkan error exception muncul ke pengguna. Template product_detail.html kemudian menampilkan semua informasi penting tentang objek tersebut, misalnya nama produk, harga, jumlah stok, dan deskripsi. Selain itu, biasanya ditambahkan tombol atau link untuk kembali ke halaman utama agar pengguna tidak terjebak di halaman detail.

6. Tidak ada

7. https://drive.google.com/drive/folders/1TIOeAAo9eDCiYky1T0wOUj4LAx3jsnlX?usp=sharing 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TUGAS 4
1. AuthenticationForm di Django adalah form bawaan yang digunakan untuk menangani proses login dengan memvalidasi username dan password pengguna terhadap sistem autentikasi Django. Form ini sudah terintegrasi dengan model User sehingga developer tidak perlu membangun form login dari nol. Kelebihannya adalah aman karena Django secara default menyimpan password dalam bentuk hash sehingga tidak ada penyimpanan plaintext password. Selain itu, Django juga sudah menyediakan error handling yang baik untuk kasus login gagal, sehingga meminimalkan risiko security leaks. Kekurangannya, penggunaan AuthenticationForm cenderung terbatas pada skenario standar. Jika aplikasi membutuhkan alur login yang lebih kompleks, seperti multi-factor authentication atau integrasi dengan sistem eksternal, maka developer tetap harus menambahkan kustomisasi atau menggunakan mekanisme lain seperti OAuth.

2. Autentikasi adalah proses verifikasi identitas pengguna, misalnya melalui login menggunakan username dan password. Sedangkan otorisasi (authorization) adalah proses verifikasi hak akses, yaitu apakah pengguna yang sudah terautentikasi memiliki izin untuk mengakses sumber daya tertentu. Django mengimplementasikan autentikasi dengan modul django.contrib.auth, yang menyediakan model User, fungsi authenticate(), serta manajemen login dan logout. Untuk otorisasi, Django menerapkan sistem permissions dan groups yang bisa dikaitkan dengan objek User, serta decorator seperti @login_required atau @permission_required pada views untuk membatasi akses. Dengan kombinasi ini, Django memisahkan dengan jelas antara proses mengenali siapa pengguna dan menentukan apa yang boleh dia lakukan.

3. Session adalah mekanisme penyimpanan state di sisi server yang mengasosiasikan data dengan session ID unik, sementara cookies menyimpan sebagian kecil data di sisi klien (browser). Kelebihan session adalah lebih aman karena data sensitif disimpan di server, dan hanya session ID yang dikirim melalui cookies. Namun, kelemahannya adalah server harus mengelola basis data session yang dapat menambah beban ketika jumlah pengguna banyak. Di sisi lain, cookies lebih ringan untuk server karena data disimpan di klien, cocok untuk menyimpan preferensi pengguna atau data yang tidak sensitif. Akan tetapi, cookies lebih rentan dimanipulasi atau diakses pihak ketiga, apalagi jika berupa persistent cookies yang tersimpan dalam file di komputer pengguna.

4. Penggunaan cookies tidak sepenuhnya aman secara default, karena cookies bisa dimanfaatkan dalam serangan seperti cross-site scripting (XSS). Risiko lain adalah ketika cookies menyimpan informasi sensitif dalam bentuk clear text sehingga mudah terbaca pihak ketiga. Django menangani hal ini dengan beberapa cara: pertama, Django secara default menggunakan session berbasis server, sehingga cookies hanya berisi session ID tanpa data sensitif. Kedua, Django menyediakan proteksi terhadap CSRF dengan token otomatis di setiap form. Selain itu, pengembang bisa mengaktifkan opsi keamanan seperti HttpOnly, Secure, dan SameSite pada cookies di file settings.py, sehingga cookies tidak bisa diakses JavaScript berbahaya, hanya dikirim melalui HTTPS, dan dibatasi lintas domain. Dengan kombinasi ini, Django membantu meminimalisir risiko penggunaan cookies.

5. 
- Membuat fungsi register yang memakai UserCreationForm lalu melakukan redirect ke halaman login setelah akun tersimpan; form HTML menyertakan {% csrf_token %} sehingga aman terhadap CSRF sesuai materi (proteksi CSRF aktif via middleware dan token di form). Login di-handle oleh login_user menggunakan AuthenticationForm; ketika form.is_valid(), kamu memanggil login(request, user) untuk membuat session pengguna, lalu mengarahkan ke halaman utama. Pada saat yang sama kamu menyetel cookie last_login di response. Logout di-handle oleh logout_user dengan logout(request) untuk mengakhiri session, menghapus cookie last_login via response.delete_cookie('last_login'), dan redirect ke halaman login. Akses halaman utama dan detail produk dibatasi dengan @login_required, sehingga pengguna yang belum login akan diarahkan ke halaman login—ini memastikan akses aplikasi sesuai status login/logout. Implementasi ini mengikuti langkah di tutorial: memakai AuthenticationForm + login(), menyetel/membaca/menghapus cookie last_login, serta penggunaan @login_required.

- Buat dua akun pengguna melalui halaman /register/, lalu masing-masing akun digunakan untuk menambahkan tiga produk melalui halaman “Add Product”. Skema ini memastikan setiap pengguna memiliki data terpisah yang terkait dengan akun mereka. Setelah data dibuat, verifikasi dapat dilakukan dari halaman utama menggunakan tombol All Products untuk melihat seluruh data dan My Products untuk menampilkan hanya data milik akun yang sedang login. Pendekatan ini sekaligus membuktikan bahwa alur autentikasi, sesi, dan pemetaan kepemilikan data ke masing-masing pengguna berjalan sesuai desain.

- Setiap Product dihubungkan dengan pemiliknya melalui field user bertipe ForeignKey ke django.contrib.auth.models.User dengan on_delete=models.CASCADE. Relasi many-to-one ini memastikan bahwa setiap produk jelas siapa pemiliknya, serta memudahkan query berbasis pengguna. Pada alur pembuatan data, objek produk dibuat dari ProductForm dengan commit=False, kemudian field product.user diisi dari request.user sebelum disimpan, sehingga seluruh produk baru otomatis tercatat atas nama pengguna yang sedang login. Dengan desain ini, pemisahan data per pengguna menjadi eksplisit dan aman, serta memudahkan implementasi fitur filter “All” vs “My”

- Halaman utama menampilkan username pengguna aktif yang diambil dari request.user.username serta informasi sesi terakhir login yang dibaca dari cookie last_login. Cookie ini disetel saat proses login berhasil dan dihapus saat logout, sehingga nilainya selalu mencerminkan aktivitas terbaru pengguna. Penayangan informasi ini memberi umpan balik yang jelas kepada pengguna mengenai status autentikasi mereka, sekaligus menunjukkan integrasi antara mekanisme session (untuk menjaga status login) dan cookie (untuk menyimpan metadata kecil seperti waktu login terakhir) pada antarmuka aplikasi.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TUGAS 5
1. deklarasi CSS yang ditulis langsung pada elemen (inline) akan menang jika bertabrakan dengan aturan di <style> (internal) maupun file .css terpisah (external), sementara bawaan browser menjadi yang terakhir dipakai jika tidak ada aturan lain yang cocok.

- Inline style
Inline style adalah aturan CSS yang ditulis langsung pada elemen HTML melalui atribut style.Style semacam ini memiliki prioritas paling tinggi karena melekat pada elemen itu sendiri. Inline berguna untuk uji cepat atau perubahan spesifik pada satu elemen.

- External style sheets
External style sheet adalah file CSS terpisah (biasanya berekstensi .css) yang dihubungkan ke file HTML. Dalam Django, file ini biasanya disimpan di folder static lalu dipanggil dengan {% load static %} dan tag <link>. External stylesheet lebih rapi, dapat digunakan di banyak halaman sekaligus, dan memudahkan konsistensi serta pemeliharaan.

- Browser default
Browser default adalah style bawaan yang diterapkan browser ketika tidak ada aturan CSS lain. Contohnya:
<h1> tampil lebih besar dan tebal dibanding <p>.
<a> biasanya berwarna biru dan bergaris bawah.
<ul> dan <ol> memiliki bullet/nomor serta margin bawaan.

2. Responsive design menjadi konsep penting dalam pengembangan aplikasi web karena pengguna mengakses internet dari berbagai jenis perangkat dengan ukuran layar yang berbeda, mulai dari smartphone, tablet, hingga desktop. Tanpa desain yang responsif, tampilan halaman akan terlihat berantakan, sulit dibaca, dan menyulitkan interaksi ketika dibuka di layar yang lebih kecil, yang pada akhirnya menurunkan pengalaman pengguna dan dapat membuat pengunjung enggan kembali. Sebaliknya, desain responsif memastikan elemen-elemen antarmuka menyesuaikan diri secara otomatis, baik dalam hal ukuran font, tata letak, maupun navigasi, sehingga nyaman digunakan di semua perangkat. Contoh aplikasi nyata yang sudah menerapkan responsive design adalah YouTube, di mana tampilan video, rekomendasi, dan navigasi akan menyesuaikan ukuran layar ponsel maupun desktop tanpa kehilangan fungsionalitas. Contoh aplikasi terkenal yang pada awalnya tidak responsif adalah LinkedIn versi lama, di mana tampilan pada perangkat mobile tidak menyesuaikan layar secara optimal sehingga teks tampak kecil, pengguna harus melakukan zoom manual, dan navigasi menjadi sulit. Perbandingan ini menegaskan bahwa responsive design bukan hanya mempercantik tampilan, tetapi juga memastikan aksesibilitas, kemudahan interaksi, dan kepuasan pengguna di berbagai perangkat modern.

3. Padding digunakan agar isi elemen (teks, gambar, input) tidak menempel langsung pada tepi border. Misalnya, pada elemen form input, jika tidak diberi padding, teks akan tampak terlalu rapat ke garis tepi sehingga kurang nyaman dibaca. Border adalah bingkai yang mengelilingi padding dan konten. Border bisa tipis, tebal, solid, putus-putus, melingkar dengan radius, atau berwarna khusus.Margin dipakai untuk memberi jarak antar elemen. Berbeda dengan padding, margin tidak memengaruhi isi elemen, tetapi memengaruhi jarak ke elemen lain.
Perbedaan paling mendasar ketiganya terletak pada posisi dan efeknya. Padding bekerja di dalam elemen dan hanya memengaruhi ruang sekitar konten, tanpa terlihat. Border bekerja di tepi elemen dan terlihat secara visual, sehingga sering dipakai untuk memberi batas atau penekanan. Margin bekerja di luar elemen dan tidak terlihat, fungsinya memberi jarak antarblok sehingga layout halaman menjadi lebih rapi.
- Padding, tujuan utama ialah memberi ruang di dalam elemen agar isi tidak dekat ke tepi.Misalnya pada global.css: padding: 0.5rem; dipakai pada input, textarea, dan select agar area ketik terasa lega dan mudah dibaca. Ketika fokus, properti visual seperti warna border dan bayangan dapat diubah untuk menonjolkan elemen aktif, contohnya border-color: #16a34a; dan box-shadow: 0 0 0 3px #16a34a;. Aturan ini menunjukkan bagaimana padding bekerja berdampingan dengan border dan efek fokus demi memberikan umpan balik visual yang jelas. Dalam contoh lain, padding dapat dibuat berbeda untuk tiap sisi menggunakan empat nilai sekaligus, misalnya padding: 20px 20px 20px 40px;, yang berarti atas 20px, kanan 20px, bawah 20px, kiri 40px; pola ini efektif untuk kasus seperti kartu konten dengan kebutuhan ruang asimetris di sisi kiri.
- Border, perannya sebagai garis tepi membuat komponen tampak terbingkai dan terpisah dari latar. Implementasi praktisnya ditunjukkan pada form: elemen input diberi border: 2px solid #bcbcbc; agar batas terlihat tegas, kemudian pada keadaan fokus warnanya diubah melalui border-color dan dapat didukung efek box-shadow agar fokus jelas.
- Margin, fungsinya adalah mengatur jarak antarelemen di luar border sehingga tata letak tidak terasa sesak. Contoh konkritnya adalah margin-bottom: 30px; pada suatu blok konten untuk memberi jarak vertikal antarbagian, atau jarak vertikal-horizontal yang lebih kaya dengan menulis margin: 16px 0;

Penggunaan stylesheet eksternal penting agar aturan bisa dipakai lintas halaman dan mudah dirawat. Di lingkungan Django, stylesheet ditempatkan di direktori static lalu dihubungkan dari template menggunakan {% load static %} dan <link rel="stylesheet" href="{% static 'css/global.css' %}"/>. Dengan pola ini, pengaturan padding, border, dan margin pada global.css akan terdistribusi konsisten ke seluruh halaman yang mewarisi base.html.

4. Flexbox adalah sistem tata letak yang digunakan untuk menyusun elemen di sepanjang bairs, baik secara horizontal maupun vertikal. Konsep ini sangat fleksibel karena memungkinkan elemen menyesuaikan ruang yang tersedia, dengan kontrol perataan melalui properti seperti justify-content untuk garis utama dan align-items untuk garis silang. Penerapannya sering digunakan untuk komponen linear seperti navbar, di mana kelas utility Tailwind flex items-center justify-between dapat membuat logo sejajar di kiri dan menu sejajar di kanan secara otomatis, menjaga tata letak tetap rapi meskipun ukuran layar berubah.

Grid layout adalah tata letak yang memungkinkan pengaturan baris dan kolom secara bersamaan. Konsep ini lebih cocok untuk tampilan halaman yang kompleks, seperti daftar produk atau galeri. Grid digunakan dengan kelas grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3, yang artinya satu kolom ditampilkan pada layar kecil, dua kolom pada layar menengah, dan tiga kolom pada layar besar. Elemen dapat tersusun rapi dalam kisi yang responsif, sehingga tata letak tetap seimbang dan mudah diakses di berbagai ukuran perangkat.

5. 
- Aktifkan dasar responsive design dan pustaka gaya. Caranya dengan menambahkan meta viewport di base.html agar tata letak menyesuaikan lebar perangkat, lalu memuat Tailwind melalui CDN pada <head>.
- Konfigurasikan static files di Django agar seluruh aset (CSS, gambar, JavaScript) tersaji rapi di mode pengembangan maupun produksi. Tambahkan WhiteNoise ke MIDDLEWARE untuk penyajian berkas statis saat DEBUG=False, kemudian pastikan STATIC_URL, STATICFILES_DIRS (saat pengembangan), dan STATIC_ROOT (saat produksi) sudah didefinisikan
- Buat static/css/global.css berisi utilitas kecil seperti styling input, textarea, select, serta checkbox kustom (termasuk efek fokus dan tanda centang). Setelah itu, tautkan berkas tersebut di base.html menggunakan {% load static %} dan <link rel="stylesheet" href="{% static 'css/global.css' %}">.
- Buat templates/navbar.html berisi tautan utama (beranda, buat konten) serta status autentikasi (tampilkan data pengguna dan tombol logout saat sudah masuk; tampilkan tautan login/register saat belum). Selanjutnya, sertakan navbar itu pada halaman utama melalui tag {% include 'navbar.html' %} di main.html. Langkah ini memusatkan navigasi di satu tempat sehingga mudah dirawat dan konsisten di seluruh halaman.
- card_product.html yang menampilkan kartu main. Selain itu, sediakan tampilan kosong (empty state) dengan ikon atau gambar ketika data belum tersedia, lalu panggil komponen kartu ini di main.html. Struktur ini membuat grid beranda tetap rapi dan komunikatif baik saat ada data maupun belum ada data.
- Halaman detail dan formulir (create/edit) kemudian diberi gaya agar selaras dengan identitas visual. Contoh di materi menunjukkan header dengan badge kategori, gambar unggulan berskala responsif, metadata (tanggal dan views), serta isi yang nyaman dibaca; sedangkan laman formulir menambahkan label, penanganan error, dan tombol aksi dengan utilitas Tailwind. Tujuannya meningkatkan keterbacaan, hierarki visual, dan aksesibilitas pada seluruh titik interaksi.
- Fitur “Edit” diimplementasikan dengan membuat fungsi view yang mengambil objek berdasarkan id memakai get_object_or_404, mengikatnya ke NewsForm/ProductForm sebagai instance, lalu menyimpan perubahan saat permintaan POST valid dan mengalihkan kembali ke halaman utama. Setelah view siap, tambahkan rute path('<uuid:id>/edit', ...) pada urls.py dan munculkan tombol “Edit” di kartu hanya untuk pemilik data yang sedang login.
- Fitur “Delete” melanjutkan pola yang sama: sediakan view yang mengambil objek lewat get_object_or_404, memanggil .delete(), lalu mengarahkan kembali ke beranda. Tambahkan rute path'<uuid:id>/delete' di urls.py, dan tampilkan tombol “Delete” berdampingan dengan “Edit”.